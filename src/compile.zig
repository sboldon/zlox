const std = @import("std");
const testing = std.testing;
const Allocator = std.mem.Allocator;

const build_options = @import("build_options");
const Context = @import("Context.zig");
const Module = @import("module.zig").Module;
const Scanner = @import("scanner.zig").Scanner;
const Token = @import("Token.zig");
const bytecode = @import("bytecode.zig");
const Value = @import("value.zig").Value;
const object = @import("object.zig");
const Obj = object.Obj;
const StringObj = object.StringObj;

const writeAllColor = @import("main.zig").writeAllColor;

pub const Error = enum(u8) {
    unknown_character,
    unexpected_token,
    empty_expression,
};

/// Maintains the state of a REPL sesssion across multiple invocations of `compileSource`.
pub const ReplCompilation = struct {
    const Self = @This();

    parser: Parser,

    pub fn init(gpa: Allocator, context: *Context) !Self {
        return Self{
            .parser = try Parser.init(gpa, context, &context.main_module, Scanner{}),
        };
    }

    pub fn compileSource(self: *Self, source: [:0]const u8) !bool {
        try self.parser.resetState(source);
        try self.parser.compileModule();
        return !self.parser.hadError();
    }
};

/// Compile a module that is not the top level. The generated bytecode is stored in `module`.
pub fn compileModule(gpa: Allocator, context: *Context, module: *Module) !bool {
    std.debug.assert(module.source_loaded);
    var parser = try Parser.init(
        gpa,
        context,
        module,
        Scanner{ .source = module.source_code },
    );
    try parser.compileModule();
    return !parser.hadError();
}

// `Parser` does not own any memory that is allocated during its execution.
const Parser = struct {
    const Self = @This();
    const max_errors = 10;

    gpa: Allocator,
    ctx: *Context,
    module: *Module,
    current_chunk: *bytecode.Chunk,

    scanner: Scanner,
    tok: Token = undefined,
    prev_tok: Token = undefined,

    panic_mode: bool = false,
    reported_errors: u8 = 0,

    /// Operator precedence from lowest to highest.
    const Precedence = enum(u8) {
        none,
        /// =
        assignment,
        /// or
        @"or",
        /// and
        @"and",
        /// == !=
        equality,
        /// < > <=  >=
        inequality,
        /// + -
        term,
        /// * /
        factor,
        /// ! -
        unary,
        /// () .
        call,
        primary,

        fn nextLevel(prec: Precedence) Precedence {
            return @intToEnum(Precedence, @enumToInt(prec) + 1);
        }
    };

    /// The parsing rule associated with each token when it begins an expression or acts as a
    /// binary operator.
    const Rule = struct {
        prefixAction: ?fn (*Self) error{OutOfMemory}!void,
        infixAction: ?fn (*Self) error{OutOfMemory}!void,
        prec: Precedence,
    };

    const rules = std.enums.directEnumArrayDefault(
        Token.Type,
        Rule,
        .{ .prefixAction = null, .infixAction = null, .prec = .none }, // Default rule.
        0,
        .{
            .keyword_nil = .{ .prefixAction = literal, .infixAction = null, .prec = .none },
            .keyword_true = .{ .prefixAction = literal, .infixAction = null, .prec = .none },
            .keyword_false = .{ .prefixAction = literal, .infixAction = null, .prec = .none },
            .number_literal = .{ .prefixAction = number, .infixAction = null, .prec = .none },
            .string_literal = .{ .prefixAction = string, .infixAction = null, .prec = .none },
            .left_paren = .{ .prefixAction = grouping, .infixAction = null, .prec = .none },

            //TODO .equal = .{ },

            .equal_equal = .{ .prefixAction = null, .infixAction = binary, .prec = .equality },
            .bang_equal = .{ .prefixAction = null, .infixAction = binary, .prec = .equality },

            .left_angle_brack = .{ .prefixAction = null, .infixAction = binary, .prec = .inequality },
            .right_angle_brack = .{ .prefixAction = null, .infixAction = binary, .prec = .inequality },
            .left_angle_brack_equal = .{ .prefixAction = null, .infixAction = binary, .prec = .inequality },
            .right_angle_brack_equal = .{ .prefixAction = null, .infixAction = binary, .prec = .inequality },

            .plus = .{ .prefixAction = null, .infixAction = binary, .prec = .term },
            .dash = .{ .prefixAction = unary, .infixAction = binary, .prec = .term },

            .star = .{ .prefixAction = null, .infixAction = binary, .prec = .factor },
            .fwd_slash = .{ .prefixAction = null, .infixAction = binary, .prec = .factor },

            .bang = .{ .prefixAction = unary, .infixAction = null, .prec = .unary },
        },
    );

    inline fn parseRule(tok_ty: Token.Type) *const Rule {
        return &rules[@enumToInt(tok_ty)];
    }

    fn init(
        gpa: Allocator,
        context: *Context,
        module: *Module,
        scanner: Scanner,
    ) !Self {
        return Self{
            .gpa = gpa,
            .ctx = context,
            .module = module,
            .current_chunk = try module.newChunk(),
            .scanner = scanner,
        };
    }

    fn resetState(self: *Self, source: [:0]const u8) !void {
        self.panic_mode = false;
        self.reported_errors = 0;
        self.current_chunk = try self.module.newChunk();
        self.scanner.setSource(source);
    }

    fn compileModule(self: *Self) !void {
        self.next();
        try self.expression();
        self.expect(.eof);
        try self.emit(.ret);
        if (comptime build_options.log_bytecode) {
            if (!self.hadError()) {
                try self.current_chunk.disassemble(std.io.getStdErr().writer(), "code");
            }
        }
    }

    fn expression(self: *Self) !void {
        try self.parsePrecedence(.assignment);
    }

    fn parsePrecedence(self: *Self, min_prec: Precedence) !void {
        self.next();
        const lhs_rule = parseRule(self.prev_tok.type);
        std.log.debug("`parsePrecedence`: `prev_tok.type` = {s}\n", .{@tagName(self.prev_tok.type)});
        if (lhs_rule.prefixAction) |prefixAction| {
            try prefixAction(self);
            while (@enumToInt(parseRule(self.tok.type).prec) >= @enumToInt(min_prec)) {
                std.log.debug(
                    "`parsePrecedence`: `self.tok.type` precedence = {}, `min_prec` = {}\n",
                    .{ @enumToInt(parseRule(self.tok.type).prec), @enumToInt(min_prec) },
                );
                self.next();
                const rhs_rule = parseRule(self.prev_tok.type);
                try rhs_rule.infixAction.?(self);
            }
        } else {
            self.errorAtPrev(.empty_expression);
        }
    }

    fn binary(self: *Self) error{OutOfMemory}!void {
        // Assumes that the lhs has already been consumed.
        const op = self.prev_tok.type;
        std.log.debug("`binary`: `op` = {s}\n", .{@tagName(op)});
        const rule = parseRule(op);
        // Precedence is incremented to enforce left-associativity.
        try self.parsePrecedence(rule.prec.nextLevel());

        const opcode: bytecode.OpCode = switch (op) {
            .equal_equal => .eq,
            .bang_equal => .neq,
            .left_angle_brack => .lt,
            .left_angle_brack_equal => .le,
            .right_angle_brack => .gt,
            .right_angle_brack_equal => .ge,
            .plus => .add,
            .dash => .sub,
            .star => .mul,
            .fwd_slash => .div,
            else => unreachable,
        };
        try self.emit(opcode);
    }

    fn grouping(self: *Self) !void {
        // Assumes that left paren is the previous token.
        try self.expression();
        self.expect(.right_paren);
    }

    fn unary(self: *Self) !void {
        // Assumes that the operator is the previous token.
        const op = self.prev_tok.type;
        std.log.debug("`unary`: `op` = {s}\n", .{@tagName(op)});

        // Ensure any additional unary operators are applied first.
        try self.parsePrecedence(.unary);

        const opcode: bytecode.OpCode = switch (op) {
            .dash => .neg,
            .bang => .not,
            else => unreachable,
        };
        try self.emit(opcode);
    }

    fn string(self: *Self) !void {
        const prev_tok_chars = self.prev_tok.loc.contents(self.scanner.source);
        // const str_obj =
        //     // Exclude surrounding quotes.
        //     try StringObj.create(self.gpa, prev_tok_chars[1 .. prev_tok_chars.len - 1]);
        // const obj = str_obj.asObj();
        // self.ctx.trackObj(obj);
        // try self.emit(Value.init(obj));
        const str_obj =
            // Exclude surrounding quotes.
            try self.ctx.createString(prev_tok_chars[1 .. prev_tok_chars.len - 1]);
        try self.emit(Value.init(str_obj.asObj()));
    }

    fn number(self: *Self) error{OutOfMemory}!void {
        // Able to disregard checking for a parse error because the number has been validated during tokenization.
        const num = std.fmt.parseFloat(
            f64,
            self.prev_tok.loc.contents(self.scanner.source),
        ) catch unreachable;
        std.log.debug("`number`: `num` = {}\n", .{num});
        try self.emit(Value.init(num));
    }

    fn literal(self: *Self) !void {
        const opcode: bytecode.OpCode = switch (self.prev_tok.type) {
            .keyword_nil => .nil,
            .keyword_true => .@"true",
            .keyword_false => .@"false",
            else => unreachable,
        };
        try self.emit(opcode);
    }

    /// Expecting `item` to be a `Value`, `bytecode.OpCode`, or `u8`.
    fn emit(self: *Self, item: anytype) !void {
        // TODO: Currently cannot give line numbers to bytecode chunk because of the location
        // information associated with each token: an offset into a source file instead of
        // line/col. This allows line & col to be calculated on demand and provides easy access to
        // source code snippets for error messages. Because line & col information is only necessary
        // in the case of an error, it is ok to find the line and col from an offset for error
        // messages as needed. However, should bytecode instructions use this same location repr? It
        // will then become necessary to be able to translate offsets into line numbers from
        // bytecode module.
        try self.current_chunk.write(item, 1);
    }

    fn next(self: *Self) void {
        // The first time `next` is called, both `prev_tok` and `tok` are uninitialized, but
        // `prev_tok` is not accessed until after `next` has been called an additional time.
        self.prev_tok = self.tok;
        self.tok = self.scanner.next();
        while (true) {
            // Skip invalid tokens.
            if (self.tok.type != Token.Type.invalid) return;
            self.errorAtCurrent(Error.unknown_character);
        }
    }

    fn expect(self: *Self, expected: Token.Type) void {
        if (self.tok.type == expected) {
            self.next();
        } else {
            self.errorAtCurrent(Error.unexpected_token);
        }
    }

    fn hadError(self: Self) bool {
        return self.reported_errors > 0;
    }

    fn errorAt(
        self: *Self,
        comptime err: Error,
        tok: Token,
    ) !void {
        if (self.panic_mode or self.reported_errors > max_errors) {
            return;
        }
        self.panic_mode = true;

        const Color = std.debug.TTY.Color;
        try writeAllColor(self.ctx.tty_config, Color.Red, Color.Bold, "error: ");
        const writer = std.io.getStdErr().writer();
        switch (err) {
            .unknown_character => {
                const ch = self.scanner.source[tok.loc.lo];
                try if (std.ascii.isPrint(ch))
                    writer.print("invalid character in current context: '{c}'\n", .{ch})
                else
                    writer.print("unknown byte: '{x}'\n", .{ch});
            },
            .unexpected_token => try writer.print("expected {s}\n", .{tok.type.toString()}),
            .empty_expression => try writer.writeAll("expected an expression\n"),
        }
        // TODO: Print location
        self.reported_errors += 1;
    }

    fn errorAtCurrent(self: *Self, comptime err: Error) void {
        errorAt(self, err, self.tok) catch return;
    }

    fn errorAtPrev(self: *Self, comptime err: Error) void {
        errorAt(self, err, self.prev_tok) catch return;
    }

    test "literals" {
        try testCase("nil", comptime .{.nil});
        try testCase("true", comptime .{.@"true"});
        try testCase("false", comptime .{.@"false"});
        try testCase("0", comptime .{Value.init(0)});
        try testCase("\"hello world\"", comptime blk: {
            var str_obj = StringObj.init("hello world");
            break :blk .{Value.init((&str_obj).asObj())};
        });
    }

    test "operators" {

        // TODO: assignment
        // TODO: or
        // TODO: and
        try testCase("1 == 2", comptime .{ Value.init(1), Value.init(2), .eq });
        try testCase("1 != 2", comptime .{ Value.init(1), Value.init(2), .neq });
        try testCase("1 < 2", comptime .{ Value.init(1), Value.init(2), .lt });
        try testCase("1 > 2", comptime .{ Value.init(1), Value.init(2), .gt });
        try testCase("1 <= 2", comptime .{ Value.init(1), Value.init(2), .le });
        try testCase("1 >= 2", comptime .{ Value.init(1), Value.init(2), .ge });
        try testCase("1 + 2", comptime .{ Value.init(1), Value.init(2), .add });
        try testCase("1 - 2", comptime .{ Value.init(1), Value.init(2), .sub });
        try testCase("1 * 2", comptime .{ Value.init(1), Value.init(2), .mul });
        try testCase("1 / 2", comptime .{ Value.init(1), Value.init(2), .div });
        try testCase("-1", comptime .{ Value.init(1), .neg });
        try testCase("!1", comptime .{ Value.init(1), .not });

        try testCase("1 - 2 + 3", comptime .{
            Value.init(1),
            Value.init(2),
            .sub,
            Value.init(3),
            .add,
        });
        try testCase("1 - (2 + 3)", comptime .{
            Value.init(1),
            Value.init(2),
            Value.init(3),
            .add,
            .sub,
        });
        try testCase("1 + 2 * 3 - 4 < !5 == 6 > 7", comptime .{
            Value.init(1),
            Value.init(2),
            Value.init(3),
            .mul,
            .add,
            Value.init(4),
            .sub,
            Value.init(5),
            .not,
            .lt,
            Value.init(6),
            Value.init(7),
            .gt,
            .eq,
        });
        try testCase("-!-1", comptime .{
            Value.init(1),
            .neg,
            .not,
            .neg,
        });

        try testCase("\"first half\" + \"second half\"", comptime blk: {
            var s1 = StringObj.init("first half");
            var s2 = StringObj.init("second half");
            break :blk .{
                Value.init((&s1).asObj()),
                Value.init((&s2).asObj()),
                .add,
            };
        });
    }

    fn testCase(source_code: [:0]const u8, expected_data: anytype) !void {
        var expected_chunk = if (@TypeOf(expected_data) == bytecode.Chunk)
            expected_data
        else blk: {
            // Expecting a comptime tuple of bytecode instructions and constants.
            var expected_chunk = bytecode.Chunk.init(testing.allocator);
            try expected_chunk.fill(expected_data);
            break :blk expected_chunk;
        };
        defer expected_chunk.deinit();

        // try expected_chunk.disassemble(std.io.getStdErr().writer(), "test");

        var context = try Context.init(testing.allocator, .{ .main_file_path = null });
        defer context.deinit();
        var module = &context.main_module;
        var self = try init(
            testing.allocator,
            &context,
            module,
            Scanner{ .source = source_code },
        );
        self.next();
        try self.expression();
        try expected_chunk.testingExpectEqual(&module.bytecode.elems[0]);
    }
};

test {
    testing.refAllDecls(@This());
}
